{% extends "public/layout/base.html" %}
{% load static %}
{% block header %}

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />

<style>
    .private-chat-container {
        width: 100%;
        height: calc(100vh - 160px);
        background: #000000;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        border-radius: 12px;
        box-shadow: 0 2px 16px rgba(0,0,0,0.18);
    }
    .private-chat-header {
        background-color: #1a1a1a;
        color: #ffffff;
        padding: 12px 16px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .private-chat-header h3 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 500;
        flex-grow: 1;
        color: #ffffff;
    }
    #private-connection-status {
        font-size: 0.75rem;
        background: rgba(255,255,255,0.1);
        color: #ffffff;
        padding: 4px 10px;
        border-radius: 12px;
        transition: all 0.3s ease;
    }
    #private-chatroom-list {
        flex: 1;
        overflow-y: auto;
        background: #ffffff30;
    }
    .private-chatroom-item {
        padding: 12px 16px;
        border-bottom: 1px solid #333333;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: #ffffff;
    }
    .private-chatroom-item:hover {
        background-color: #222222;
    }
    .private-chatroom-item.unread {
        background-color: #333333;
    }
    .private-chatroom-title {
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        color: #ffffff;
    }
    .private-chatroom-unread-count {
        background: #ffffff;
        color: #000000;
        border-radius: 50%;
        width: 18px;
        height: 18px;
        font-size: 11px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #private-chat-messages {
        flex: 1;
        padding: 16px;
        overflow-y: auto;
        background: #111111;
        display: none;
        flex-direction: column;
        gap: 12px;
    }
    .private-message {
        padding: 10px 14px;
        border-radius: 12px;
        max-width: 80%;
        word-break: break-word;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        position: relative;
        color: #ffffff;
    }
    .private-message.sent {
        background-color: #333333;
        margin-left: auto;
        border-top-right-radius: 4px;
    }
    .private-message.received {
        background-color: #222222;
        margin-right: auto;
        border-top-left-radius: 4px;
    }
    .private-message-sender {
        font-weight: 600;
        font-size: 0.85rem;
        margin-bottom: 4px;
    }
    .private-message-sender.admin {
        color: #4a6fdc;
    }
    .private-message-sender.customer {
        color: var(--user-color, #ffffff);
    }
    .private-message-time {
        font-size: 0.7rem;
        color: #aaaaaa;
        text-align: right;
        margin-top: 4px;
    }
    .private-message-status {
        font-size: 0.65rem;
        text-align: right;
        margin-top: 2px;
        color: #aaaaaa;
    }
    .unread-label {
        background: #fffbe6;
        color: #c77d00;
        padding: 6px 12px;
        border-radius: 8px;
        margin: 8px 0;
        font-size: 0.95rem;
        font-weight: 600;
        display: inline-block;
    }

    #private-message-input {
        padding: 12px 16px;
        border-top: 1px solid #333333;
        background: #000000;
        position: sticky;
        bottom: 0;
    }
    #private-chat-input {
        padding: 10px 16px;
        border: 1px solid #444444;
        border-radius: 20px;
        font-size: 0.9rem;
        outline: none;
        transition: all 0.3s ease;
        background: #111111;
        color: #ffffff;
        flex-grow: 1;
        resize: none;
        min-height: 38px;
        max-height: 150px;
    }
    #private-chat-input:focus {
        border-color: #ffffff;
        box-shadow: 0 0 0 3px rgba(255,255,255,0.1);
    }
    #private-send-button {
        padding: 8px 20px;
        background-color: #000000;
        color: #ffffff;
        border: 1px solid white;
        border-radius: 20px;
        font-size: 0.9rem;
        font-weight: 500;
        transition: all 0.3s ease;
    }
    #private-send-button:hover {
        background-color: #222222;
        transform: translateY(-1px);
    }
    #private-typing-indicator {
        font-size: 0.75rem;
        color: #aaaaaa;
        height: auto;
        margin-top: 8px;
        min-height: 18px;
    }
    .private-btn-icon {
        background: none;
        border: none;
        color: #ffffff;
        font-size: 1.2rem;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    .private-btn-icon:hover {
        color: #cccccc;
    }
    #private-toast-notification {
        position: fixed;
        top: 80px;
        right: 15px;
        z-index: 1100;
        max-width: 300px;
        min-width: 180px;
        pointer-events: none;
    }
    .toast-message {
        background: #333;
        color: #fff;
        padding: 10px 18px;
        border-radius: 7px;
        font-size: 0.95rem;
        margin-top: 6px;
        box-shadow: 0 1px 7px rgba(0,0,0,0.15);
        animation: fadeIn 0.25s;
        opacity: 1;
        transition: opacity 0.6s;
    }
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px);}
        to   { opacity: 1; transform: translateY(0);}
    }
    .private-message-image {
        max-width: 100%;
        max-height: 300px;
        border-radius: 8px;
        margin-top: 8px;
        cursor: pointer;
        transition: transform 0.2s;
    }
    .private-message-image:hover {
        transform: scale(1.02);
    }
    #unread-message-label.show {
        display: inline-block;
        transition: top 0.3s ease-in-out;
    }

    #private-image-upload-btn {
        background: none;
        border: none;
        color: #ffffff;
        font-size: 1.2rem;
        cursor: pointer;
        padding: 0 8px;
    }
    #private-image-upload-btn:hover {
        color: #cccccc;
    }
    #private-image-preview-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.9);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 3000;
    }
    #private-image-preview-content {
        max-width: 90%;
        max-height: 90%;
    }
    #private-image-preview-content img {
        max-width: 100%;
        max-height: 90vh;
        object-fit: contain;
    }
    #private-close-preview {
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        font-size: 2rem;
        cursor: pointer;
    }
    .private-upload-progress {
        width: 100%;
        height: 4px;
        background: #333333;
        margin-top: 8px;
        border-radius: 2px;
        overflow: hidden;
        display: none;
    }
    .private-upload-progress-bar {
        height: 100%;
        background: #4a6fdc;
        width: 0%;
        transition: width 0.3s;
    }
    #private-chat-input-container {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    #private-back-button {
        display: none;
    }
    @media (max-width: 767px) {
        #private-message-input {
            position: fixed !important;
            bottom: 0;
            left: 0;
            width: 100vw;
            z-index: 20;
            background: #000;
        }
        .private-chat-container {
            height: calc(100vh - 55px);
        }
    }
</style>
{% endblock %}

{% block content %}
<section class="section bg-black">
    <div class="container">
        <div class="layout-specing">
            <div class="row">
                <!-- START SIDEBAR -->
                <div class="col-lg-3 col-12 mt-4 mt-lg-0 pt-2 pt-lg-0">
                    {% include "customer/sidebar.html" %}
                </div>
                <!-- START MAIN CONTENT -->
                <div class="col-lg-9 col-12">
                    <div class="private-chat-container" data-user-role="{{ user_data.role|escapejs }}" data-user-id="{{ user_data.user_id }}" data-is-authenticated="{{ user_data.is_authenticated|yesno:'true,false' }}">
                        <div id="unread-message-label" style="position: absolute; z-index: 10; left: 20px; background: #fffbe6; color: #c77d00; padding: 6px 12px; border-radius: 8px; font-weight: bold; display: none;">New unread messages</div>

                        {% if user_data.is_authenticated %}
                        <div class="private-chat-header">
                            <button id="private-back-button" class="private-btn-icon" aria-label="Back to chatroom list">
                                <i class="fas fa-arrow-left" aria-hidden="true"></i>
                            </button>
                            <h3 id="private-chat-header">Private Chats</h3>
                            <div class="d-flex align-items-center gap-2">
                                <span id="private-connection-status">Ready</span>
                            </div>
                        </div>

                        <div id="private-chatroom-list">
                            <div id="private-chatrooms-container"></div>
                        </div>
                        <div id="private-chat-messages"></div>
                        <div id="private-message-input" style="display: none;">
                            <div id="private-chat-input-container">
                                <button id="private-image-upload-btn" aria-label="Upload image">
                                    <i class="fas fa-image" aria-hidden="true"></i>
                                </button>
                                <textarea id="private-chat-input" class="form-control" placeholder="Type your message..." autocomplete="off" aria-label="Message input"></textarea>
                                <button id="private-send-button" class="btn" aria-label="Send message">Send</button>
                            </div>
                            <div class="private-upload-progress">
                                <div class="private-upload-progress-bar"></div>
                            </div>
                            <div id="private-typing-indicator"></div>
                        </div>

                        <div id="private-image-preview-modal">
                            <span id="private-close-preview" aria-label="Close image preview">×</span>
                            <div id="private-image-preview-content">
                                <img src="" alt="Preview">
                            </div>
                        </div>
                        <div id="private-toast-notification"></div>
                        {% else %}
                        <div class="p-4 text-center text-white">
                            Please log in to access private chats
                        </div>
                        {% endif %}
                    </div>
                    <input type="file" id="private-file-input" accept="image/*" style="display: none;" aria-hidden="true">
                </div>
            </div>
        </div>
    </div>
</section>
{% endblock content %}

{% block script %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const chatWidget = document.querySelector('.private-chat-container');
    if (!chatWidget) return;
    const elements = {
        chatContainer: chatWidget,
        chatMessages: document.getElementById('private-chat-messages'),
        chatroomList: document.getElementById('private-chatroom-list'),
        chatroomsContainer: document.getElementById('private-chatrooms-container'),
        chatInput: document.getElementById('private-chat-input'),
        sendButton: document.getElementById('private-send-button'),
        connectionStatus: document.getElementById('private-connection-status'),
        typingIndicator: document.getElementById('private-typing-indicator'),
        backButton: document.getElementById('private-back-button'),
        chatHeader: document.getElementById('private-chat-header'),
        toastNotification: document.getElementById('private-toast-notification'),
        imageUploadBtn: document.getElementById('private-image-upload-btn'),
        fileInput: document.getElementById('private-file-input'),
        imagePreviewModal: document.getElementById('private-image-preview-modal'),
        closePreview: document.getElementById('private-close-preview'),
        messageInput: document.getElementById('private-message-input'),
    };
    const state = {
        globalSocket: null,
        currentRoomId: null,
        currentRoomName: null,
        pingInterval: null,
        reconnectAttempts: 0,
        maxReconnectAttempts: 5,
        typingTimer: null,
        typingDelay: 1000,
        currentView: 'chatrooms',
        userRole: chatWidget.dataset.userRole || '',
        currentUserId: chatWidget.dataset.userId || '',
        isAuthenticated: chatWidget.dataset.isAuthenticated === 'true',
        renderedMessageIds: new Set()
    };
    if (!state.isAuthenticated) return;

    function getUserColor(id) {
        if (!id) return '#ffffff';
        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEEAD',
            '#D4A5A5', '#9B59B6', '#3498DB', '#E67E22', '#2ECC71'
        ];
        const index = String(id).split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
        return colors[index % colors.length];
    }

    async function handleImageUpload(file) {
        if (!file || !file.type.match('image.*')) {
            showToast('Please select a valid image');
            return;
        }
        if (file.size > 5 * 1024 * 1024) {
            showToast('Image size should be less than 5MB');
            return;
        }
        const formData = new FormData();
        formData.append('image', file);
        formData.append('room_id', state.currentRoomId);

        const progressBar = document.querySelector('.private-upload-progress-bar');
        const uploadProgress = document.querySelector('.private-upload-progress');
        if (!progressBar || !uploadProgress) return;

        uploadProgress.style.display = 'block';
        progressBar.style.width = '0%';

        try {
            const response = await fetch('/api/chat/upload-image/', {
                method: 'POST',
                body: formData,
                credentials: 'include',
                headers: {
                    'X-CSRFToken': getCSRFToken(),
                },
            });
            if (!response.ok) throw new Error('Upload failed');
            const data = await response.json();

            if (state.globalSocket?.readyState === WebSocket.OPEN) {
                state.globalSocket.send(JSON.stringify({
                    type: 'image',
                    room_id: state.currentRoomId,
                    image_url: data.image_url,
                    content: 'Image shared'
                }));
            }
            loadMessages(state.currentRoomId)
            progressBar.style.width = '100%';
            setTimeout(() => uploadProgress.style.display = 'none', 500);
        } catch (error) {
            showToast('Failed to upload image');
            uploadProgress.style.display = 'none';
        }
    }

    function renderImageMessage(message) {
        const isCurrentUser = message.sender === state.currentUserId;
        const messageElement = document.createElement('div');
        messageElement.className = `private-message ${isCurrentUser ? 'sent' : 'received'}`;
        messageElement.dataset.messageId = message.id;

        const senderDiv = document.createElement('div');
        senderDiv.className = 'private-message-sender';
        const isAdmin = message.sender_role === 'admin' || 
            (message.sender && message.sender.is_staff) ||
            (message.sender_email && message.sender_email.includes('admin'));
        if (isAdmin) senderDiv.classList.add('admin');
        else {
            senderDiv.classList.add('customer');
            const colorId = message.sender_id || message.sender_email || message.sender_name || 'default';
            senderDiv.style.setProperty('--user-color', getUserColor(colorId));
        }
        senderDiv.textContent = isCurrentUser ? 'You' : (message.sender_name || 'Anonymous');
        const contentDiv = document.createElement('div');
        contentDiv.textContent = message.content || '';
        const timeDiv = document.createElement('div');
        timeDiv.className = 'private-message-time';
        timeDiv.textContent = message.timestamp;
        messageElement.appendChild(senderDiv);
        messageElement.appendChild(contentDiv);

        if (message.image_url) {
            const img = document.createElement('img');
            img.src = message.image_url;
            img.className = 'private-message-image';
            img.alt = 'Uploaded image';
            img.addEventListener('click', () => {
                if (elements.imagePreviewModal) {
                    elements.imagePreviewModal.querySelector('img').src = img.src;
                    elements.imagePreviewModal.style.display = 'flex';
                }
            });
            messageElement.appendChild(img);
        }
        messageElement.appendChild(timeDiv);

        if (isCurrentUser) {
            const statusDiv = document.createElement('div');
            statusDiv.className = `private-message-status ${message.is_read ? 'text-success' : 'text-white'}`;
            statusDiv.textContent = message.is_read ? '✓ Read' : '✓ Delivered';
            messageElement.appendChild(statusDiv);
        }
        return messageElement;
    }

    async function initChat() {
        connectGlobalWebSocket();
        setInterval(fetchUnreadCounts, 10000);

        const response = await fetch('/api/chat/rooms/list/', { credentials: 'include' });
        if (!response.ok) {
            showToast('Failed to load conversations');
            return;
        }
        const privateRooms = await response.json();
        const allRooms = privateRooms.sort((a, b) => {
            const aTime = new Date(a.last_message?.timestamp || a.created_at);
            const bTime = new Date(b.last_message?.timestamp || b.created_at);
            return bTime - aTime;
        });
        renderChatrooms(allRooms);
    }

    async function showChatroomList() {
        state.currentView = 'chatrooms';
        elements.chatroomList.style.display = 'block';
        elements.chatMessages.style.display = 'none';
        elements.messageInput.style.display = 'none';
        elements.backButton.style.display = 'none';
        elements.chatHeader.textContent = 'Private Chats';

        const response = await fetch('/api/chat/rooms/list/', { credentials: 'include' });
        if (!response.ok) {
            showToast('Failed to load conversations');
            return;
        }
        const privateRooms = await response.json();
        const allRooms = privateRooms.sort((a, b) => {
            const aTime = new Date(a.last_message?.timestamp || a.created_at);
            const bTime = new Date(b.last_message?.timestamp || b.created_at);
            return bTime - aTime;
        });
        renderChatrooms(allRooms);
    }

    async function readMessages(roomId) {
        try {
            const csrfToken = getCSRFToken();
            const response = await fetch(`/api/chat/rooms/${roomId}/read/`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken,
                },
                credentials: 'include'
            });
            if (!response.ok) throw new Error('Failed to mark messages as read');
        } catch (error) {}
    }

    function renderChatrooms(chatrooms) {
        elements.chatroomsContainer.innerHTML = '';
        if (!chatrooms || !chatrooms.length) {
            const emptyMsg = document.createElement('div');
            emptyMsg.className = 'p-3 text-center text-white';
            emptyMsg.textContent = 'No private conversations yet';
            elements.chatroomsContainer.appendChild(emptyMsg);
            return;
        }
        chatrooms.forEach(chatroom => {
            const chatroomElement = document.createElement('div');
            chatroomElement.className = `private-chatroom-item ${chatroom.unread_count > 0 ? 'unread' : ''}`;
            let name = '', avatarContent = '';
            if (state.userRole === 'customer') {
                name = chatroom.subject;
                avatarContent = 'A';
            } else {
                name = `${chatroom.customer_name} - ${chatroom.subject}`;
                avatarContent = chatroom.customer_name ? chatroom.customer_name.charAt(0).toUpperCase() : 'S';
            }
            const avatarDiv = document.createElement('div');
            avatarDiv.style.cssText = 'width:30px; height:30px; border-radius:50%; background-color:white; color:black; justify-content:center; display:grid; align-items:center; text-align:center;';
            avatarDiv.textContent = avatarContent;
            const titleDiv = document.createElement('div');
            titleDiv.className = 'private-chatroom-title';
            titleDiv.textContent = name || 'Support Team';
            if (chatroom.unread_count > 0) {
                const unreadSpan = document.createElement('span');
                unreadSpan.className = 'private-chatroom-unread-count';
                unreadSpan.textContent = chatroom.unread_count;
                titleDiv.appendChild(unreadSpan);
            }
            const lastMessageDiv = document.createElement('div');
            lastMessageDiv.className = 'text-white';
            lastMessageDiv.style.cssText = 'font-size: 0.8rem; margin-top: 4px;';
            if (chatroom.last_message) {
                const lastMessageSpan = document.createElement('span');
                lastMessageSpan.className = chatroom.unread_count > 0 ? 'fw-semibold' : '';
                lastMessageSpan.textContent = `${chatroom.last_message.sender_name || 'System'}: ${
                    chatroom.last_message.message_type === 'image' ? '[Image]' : 
                    chatroom.last_message.content.substring(0, 40) + (chatroom.last_message.content.length > 40 ? '...' : '')
                }`;
                lastMessageDiv.appendChild(lastMessageSpan);
            } else {
                lastMessageDiv.textContent = 'No messages yet';
            }
            const timeDiv = document.createElement('div');
            timeDiv.className = 'text-white text-end';
            timeDiv.style.cssText = 'font-size: 0.75rem; min-width: 50px;';
            timeDiv.textContent = chatroom.last_message ? chatroom.last_message.timestamp : '';
            const contentDiv = document.createElement('div');
            contentDiv.className = 'd-flex flex-column flex-grow-1';
            contentDiv.appendChild(titleDiv);
            contentDiv.appendChild(lastMessageDiv);
            const rowDiv = document.createElement('div');
            rowDiv.className = 'd-flex flex-row';
            rowDiv.style.gap = '20px';
            rowDiv.appendChild(avatarDiv);
            rowDiv.appendChild(contentDiv);
            chatroomElement.appendChild(rowDiv);
            chatroomElement.appendChild(timeDiv);
            chatroomElement.addEventListener('click', () => {
                const roomName = state.userRole === 'customer' ? 
                    chatroom.subject : 
                    `${chatroom.customer_name} - ${chatroom.subject}` || 'Support';
                openChatroom(chatroom.id, roomName);
            });
            elements.chatroomsContainer.appendChild(chatroomElement);
        });
    }

    async function openChatroom(roomId, roomName) {
        state.currentView = 'messages';
        state.currentRoomId = roomId;
        state.currentRoomName = roomName;

        elements.chatroomList.style.display = 'none';
        elements.chatMessages.style.display = 'flex';
        elements.messageInput.style.display = 'block';
        elements.backButton.style.display = 'block';
        elements.chatHeader.textContent = roomName;

        // Clear rendered message IDs when opening a new room
        state.renderedMessageIds.clear();

        try {
            const response = await fetch(`/api/chat/rooms/${roomId}/messages/`, { credentials: 'include' });
            if (!response.ok) throw new Error('Failed to load messages');
            const messages = await response.json();
            elements.chatMessages.innerHTML = '';
            state.renderedMessageIds.clear();

            if (!messages.length) {
                showNoMessagesPlaceholder();
            } else {
                // Find the index of the first unread message for the current user
                let firstUnreadIndex = -1;
                for (let i = 0; i < messages.length; i++) {
                    const msg = messages[i];
                    if (
                        msg.sender_id !== state.currentUserId &&
                        Array.isArray(msg.unread_by) &&
                        msg.unread_by.includes(state.currentUserId)
                    ) {
                        firstUnreadIndex = i;
                        break;
                    }
                }

                messages.forEach((msg, idx) => {
                    if (idx === firstUnreadIndex) {
                        // Insert the "New unread messages" label just before this message
                        const unreadLabel = document.createElement('div');
                        unreadLabel.className = 'unread-label text-center my-2';
                        unreadLabel.textContent = 'New unread messages';
                        elements.chatMessages.appendChild(unreadLabel);
                    }
                    addMessageToChat(msg);
                });

                // After DOM is updated, scroll to the first unread message (skip the label)
                setTimeout(() => {
                    if (firstUnreadIndex !== -1) {
                        // Find all message elements (skip the label)
                        const messageElements = elements.chatMessages.querySelectorAll('.private-message');
                        if (messageElements[firstUnreadIndex]) {
                            messageElements[firstUnreadIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                        } else {
                            scrollToBottom();
                        }
                    } else {
                        scrollToBottom();
                    }
                }, 100);

                // Now call readMessages API
                readMessages(roomId);
            }
        } catch (error) {
            console.error('Failed to load messages:', error);
            showToast('Failed to load messages');
        }

        if (state.globalSocket?.readyState === WebSocket.OPEN) {
            state.globalSocket.send(JSON.stringify({
                type: 'join',
                room_id: state.currentRoomId
            }));
        }
    }

    async function loadMessages(roomId) {
        if (!roomId || roomId !== state.currentRoomId) return;

        try {
            const response = await fetch(`/api/chat/rooms/${roomId}/messages/`, { credentials: 'include' });
            if (!response.ok) throw new Error('Failed to load messages');
            const messages = await response.json();
            
            // Only clear messages if we're in the correct room
            if (roomId === state.currentRoomId) {
                elements.chatMessages.innerHTML = '';
                state.renderedMessageIds.clear();

                if (!messages.length) {
                    showNoMessagesPlaceholder();
                    return;
                }

                // Find the index of the first unread message for the current user
                let firstUnreadIndex = -1;
                for (let i = 0; i < messages.length; i++) {
                    const msg = messages[i];
                    // Check if current user is in unread_by list (for received messages)
                    if (msg.sender_id !== state.currentUserId && 
                        Array.isArray(msg.unread_by) && 
                        msg.unread_by.includes(state.currentUserId)) {
                        firstUnreadIndex = i;
                        break;
                    }
                }

                messages.forEach((msg, idx) => {
                    if (idx === firstUnreadIndex) {
                        // Insert the "New unread messages" label just before this message
                        const unreadLabel = document.createElement('div');
                        unreadLabel.className = 'unread-label text-center my-2';
                        unreadLabel.textContent = 'New unread messages';
                        elements.chatMessages.appendChild(unreadLabel);
                    }
                    addMessageToChat(msg);
                });

                // Scroll to bottom for sent messages, or to first unread for received
                setTimeout(() => {
                    if (firstUnreadIndex !== -1) {
                        const messageElements = elements.chatMessages.querySelectorAll('.private-message');
                        if (messageElements[firstUnreadIndex]) {
                            messageElements[firstUnreadIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                        } else {
                            scrollToBottom();
                        }
                    } else {
                        scrollToBottom();
                    }
                }, 100);
            }
        } catch (error) {
            console.error('Failed to load messages:', error);
            showToast('Failed to load messages');
        }
    }

    function playNotification() {
        try {
            const sound = new Audio('/static/sounds/notification.mp3');
            sound.play().catch(e => {});
        } catch (e) {}
    }

    function connectGlobalWebSocket() {
        if (state.globalSocket) {
            state.globalSocket.close();
            clearInterval(state.pingInterval);
        }
        const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const wsUrl = `${protocol}${window.location.host}/ws/chat/global/`;
        state.globalSocket = new WebSocket(wsUrl);

        state.globalSocket.onopen = () => {
            state.reconnectAttempts = 0;
            updateConnectionStatus('Online');
            state.pingInterval = setInterval(() => {
                if (state.globalSocket.readyState === WebSocket.OPEN) {
                    state.globalSocket.send(JSON.stringify({ type: 'ping' }));
                }
            }, 25000);
            if (state.currentRoomId) {
                state.globalSocket.send(JSON.stringify({
                    type: 'join',
                    room_id: state.currentRoomId
                }));
            }
        };

        state.globalSocket.onmessage = async (e) => {
            try {
                const data = JSON.parse(e.data);
                
                if (data.type === 'pong') return;
                if (data.type === 'error') {
                    showToast(data.error);
                    return;
                }
                
                if (data.is_typing === true) {
                    if (data.sender_id !== state.currentUserId && state.currentRoomId === data.room_id) {
                        elements.typingIndicator.textContent = 'Someone is typing...';
                        setTimeout(() => elements.typingIndicator.textContent = '', 3000);
                    }
                    return;
                }
                
                if (data.type === 'chat' || data.type === 'image') {
                    if (data.room_id === state.currentRoomId) {
                        // For current room, just load messages which will handle unread labels
                        loadMessages(data.room_id);
                        readMessages(data.room_id);
                        return;
                    }
                    
                    // For other rooms, show notification and update counts
                    fetchUnreadCounts();
                    showToast(`New message received in ${data.room_name}`);
                    playNotification();
                }
            } catch (error) {
                showToast('Error processing message');
            }
        };

        state.globalSocket.onclose = (e) => {
            clearInterval(state.pingInterval);
            if (e.code === 1000) {
                updateConnectionStatus('Offline');
                return;
            }
            updateConnectionStatus('Reconnecting...');
            if (state.reconnectAttempts < state.maxReconnectAttempts) {
                state.reconnectAttempts++;
                const delay = Math.min(3000 * Math.pow(2, state.reconnectAttempts), 30000);
                setTimeout(connectGlobalWebSocket, delay);
            } else {
                updateConnectionStatus('Disconnected', true);
                showToast('Connection lost. Please refresh.');
            }
        };

        state.globalSocket.onerror = (error) => {
            updateConnectionStatus('Connection error', true);
            showToast('WebSocket connection error');
        };
    }

    function addMessageToChat(message) {
        if (state.renderedMessageIds.has(message.id)) return;
        state.renderedMessageIds.add(message.id);
        
        if (message.message_type === 'image') {
            elements.chatMessages.appendChild(renderImageMessage(message));
        } else {
            const isCurrentUser = message.sender === state.currentUserId;
            const messageElement = document.createElement('div');
            messageElement.className = `private-message ${isCurrentUser ? 'sent' : 'received'}`;
            messageElement.dataset.messageId = message.id;
            
            const senderDiv = document.createElement('div');
            senderDiv.className = 'private-message-sender';
            const isAdmin = message.sender_role === 'admin' || 
                (message.sender && message.sender.is_staff) ||
                (message.sender_email && message.sender_email.includes('admin'));
            if (isAdmin) senderDiv.classList.add('admin');
            else {
                senderDiv.classList.add('customer');
                const colorId = message.sender_id || message.sender_email || message.sender_name || 'default';
                senderDiv.style.setProperty('--user-color', getUserColor(colorId));
            }
            senderDiv.textContent = isCurrentUser ? 'You' : (message.sender_name || 'Anonymous');
            
            const contentDiv = document.createElement('div');
            contentDiv.textContent = message.content;
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'private-message-time';
            timeDiv.textContent = message.timestamp;
            
            messageElement.appendChild(senderDiv);
            messageElement.appendChild(contentDiv);
            messageElement.appendChild(timeDiv);
            
            if (isCurrentUser) {
                const statusDiv = document.createElement('div');
                statusDiv.className = `private-message-status ${message.is_read ? 'text-success' : 'text-white'}`;
                statusDiv.textContent = message.is_read ? '✓ Read' : '✓ Delivered';
                messageElement.appendChild(statusDiv);
            }
            
            elements.chatMessages.appendChild(messageElement);
        }
    }

    function showNoMessagesPlaceholder() {
        const placeholder = document.createElement('div');
        placeholder.className = 'text-center p-4 text-white';
        placeholder.textContent = 'No messages yet. Start the conversation!';
        elements.chatMessages.appendChild(placeholder);
    }

    async function sendMessage() {
        const message = elements.chatInput.value.trim();
        if (!message || !state.currentRoomId) return;
        
        try {
            if (!state.globalSocket || state.globalSocket.readyState !== WebSocket.OPEN) {
                throw new Error('WebSocket not connected');
            }
            
            elements.chatInput.value = '';
            state.globalSocket.send(JSON.stringify({
                type: 'chat',
                message,
                room_id: state.currentRoomId
            }));
            
            // For sent messages, just scroll to bottom without reloading
            scrollToBottom();
        } catch (error) {
            showToast('Failed to send message');
        }
    }

    async function fetchUnreadCounts() {
        try {
            const response = await fetch('/api/chat/notifications/', { credentials: 'include' });
            if (!response.ok) throw new Error('Failed to fetch notifications');
            const data = await response.json();
            // Update UI with unread counts if needed
        } catch (error) {
            console.error('Failed to fetch unread counts:', error);
        }
    }

    function handleTyping() {
        if (state.typingTimer) clearTimeout(state.typingTimer);
        if (elements.chatInput.value.trim().length > 0) {
            elements.typingIndicator.textContent = 'You are typing...';
            if (state.globalSocket?.readyState === WebSocket.OPEN) {
                state.globalSocket.send(JSON.stringify({
                    type: 'typing',
                    is_typing: true,
                    room_id: state.currentRoomId
                }));
            }
            state.typingTimer = setTimeout(() => {
                elements.typingIndicator.textContent = '';
            }, state.typingDelay);
        } else {
            elements.typingIndicator.textContent = '';
        }
    }

    function scrollToBottom() {
        elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
    }

    function getCSRFToken() {
        const metaTag = document.querySelector('meta[name="csrf-token"]');
        if (metaTag) return metaTag.getAttribute('content');
        const cookieValue = document.cookie.match('(^|;)\\s*csrftoken\\s*=\\s*([^;]+)');
        return cookieValue ? cookieValue.pop() : null;
    }

    function showToast(message, duration=3500) {
        if (!elements.toastNotification) return;
        const toast = document.createElement('div');
        toast.textContent = message;
        toast.style.marginBottom = '8px';
        toast.className = 'toast-message show';
        toast.style.opacity = '1';
        toast.style.transition = 'opacity 0.6s';
        elements.toastNotification.appendChild(toast);
        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => {
                if (toast.parentNode) toast.parentNode.removeChild(toast);
            }, 600);
        }, duration);
    }

    function updateConnectionStatus(status, isError = false) {
        elements.connectionStatus.textContent = status;
        elements.connectionStatus.className = 'px-2 py-1 rounded-pill';
        if (status.toLowerCase().includes('online')) {
            elements.connectionStatus.style.background = '#2ecc71';
            elements.connectionStatus.style.color = '#fff';
        } else if (status.toLowerCase().includes('offline')) {
            elements.connectionStatus.style.background = '#e74c3c';
            elements.connectionStatus.style.color = '#fff';
        } else if (status.toLowerCase().includes('reconnect')) {
            elements.connectionStatus.style.background = '#e67e22';
            elements.connectionStatus.style.color = '#fff';
        } else {
            elements.connectionStatus.style.background = '#bdc3c7';
            elements.connectionStatus.style.color = '#333';
        }
    }

    function attachEventListeners() {
        if (elements.backButton) {
            elements.backButton.addEventListener('click', showChatroomList);
        }
        if (elements.sendButton) {
            elements.sendButton.addEventListener('click', sendMessage);
        }
        if (elements.chatInput) {
            elements.chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    sendMessage();
                } else if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    const val = elements.chatInput.value;
                    const start = elements.chatInput.selectionStart;
                    elements.chatInput.value = val.slice(0, start) + "\n" + val.slice(start);
                    elements.chatInput.selectionStart = elements.chatInput.selectionEnd = start + 1;
                    e.preventDefault();
                }
            });
            elements.chatInput.addEventListener('input', handleTyping);
        }
        if (elements.imageUploadBtn) {
            elements.imageUploadBtn.addEventListener('click', () => {
                elements.fileInput.click();
            });
        }
        if (elements.fileInput) {
            elements.fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleImageUpload(file);
                    e.target.value = '';
                }
            });
        }
        if (elements.closePreview) {
            elements.closePreview.addEventListener('click', () => {
                elements.imagePreviewModal.style.display = 'none';
            });
        }
        if (elements.imagePreviewModal) {
            elements.imagePreviewModal.addEventListener('click', (e) => {
                if (e.target === elements.imagePreviewModal) {
                    elements.imagePreviewModal.style.display = 'none';
                }
            });
        }
    }

    attachEventListeners();
    initChat();
    // Autofocus input when chat opens (esp. mobile)
    if (elements.chatInput) setTimeout(() => { elements.chatInput.focus(); }, 400);
});
</script>
{% endblock script %}